<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
    <title>My first three.js app</title>
    
		<style>
			body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
        }

        #css, #webgl {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
        }

        #css {
          background: transparent;
        }

        #css div div {
          pointer-events: auto !important;
        }

    </style>
    
  </head>
  
	<body>


		<script type="module">
      import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.129.0-chk6X8RSBl37CcZQlxof/mode=imports/optimized/three.js';
      import { RGBELoader } from 'https://cdn.skypack.dev/three@v0.129.0-chk6X8RSBl37CcZQlxof/examples/jsm/loaders/RGBELoader.js';
      import { GUI } from 'https://cdn.skypack.dev/three@v0.129.0-chk6X8RSBl37CcZQlxof/examples/jsm/libs/dat.gui.module.js';
			import { OrbitControls } from 'https://cdn.skypack.dev/three@v0.129.0-chk6X8RSBl37CcZQlxof/examples/jsm/controls/OrbitControls.js';
      import { CSS3DRenderer, CSS3DObject } from 'https://cdn.skypack.dev/three@v0.129.0-chk6X8RSBl37CcZQlxof/examples/jsm/renderers/CSS3DRenderer.js';
      // import Stats from 'https://cdn.skypack.dev/three@v0.129.0-chk6X8RSBl37CcZQlxof/examples/jsm/libs/stats.module.js';
      // import { FirstPersonControls } from '/js/three/jsm/controls/FirstPersonControls.js';

      let camera, scene, scene2, renderer, renderer2, light, light2, raycaster;
      let controls, controls2;
      let iframes = [];
      const QUARTER_CIRCLE = Math.PI / 2;

      const clock = new THREE.Clock();

      const mouse = new THREE.Vector2();
      const target = new THREE.Vector2();
      const windowHalf = new THREE.Vector2( window.innerWidth / 2, window.innerHeight / 2 );
      let controlUpdateState;
      let orbitControlFlag = false;
      let camStatus = new THREE.Euler( 0, 0, 0, 'XYZ' );

      let INTERSECTED;
      const pointer = new THREE.Vector2();

      // const container = document.getElementById( 'container' );
      // const stats = new Stats();
			// container.appendChild( stats.dom );

      

      init();
      render();
      animate(performance.now());

      function init(){
        //add camera
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 1;
        camStatus = camera.rotation;
        console.log(camera);

        //add scene
        scene = new THREE.Scene();
        scene2 = new THREE.Scene();
        console.log(scene);
        scene.background = new THREE.CubeTextureLoader()
          .setPath("img/Skies_1/background/")
          .load( [
            'px.png',
            'nx.png',
            'py.png',
            'ny.png',
            'pz.png',
            'nz.png'
          ] );
        
        //add domElements
        for (let i=0; i<6; i++) {
          let elementObj = makeElementObject( 'iframe', 1050, 800 );
          elementObj.css3dObject.element.setAttribute('src', 'iframes/1.html');
          elementObj.css3dObject.element.style.border = '1px solid transparent';
          elementObj.css3dObject.element.style.borderRadius = '40px';
          let frameBlock = elementObj.css3dObject.element;
          
          frameBlock.onload = function(){
            // let docBlock = frameBlock.contentDocument.querySelector('#slider');
            // docBlock.style.display = 'block';
            // let docBlock2 = frameBlock.contentDocument.querySelector('#info');
            // docBlock2.style.display = 'none';
            let sections = frameBlock.contentDocument.querySelectorAll('section');
            Array.from(sections).forEach(function(element) {
              element.style.display = 'none';
            });
            sections.item(i).style.display = 'block'

            if(i === 0) {
              let nextSliderButton = frameBlock.contentDocument.querySelector('.slider-btn-next');
              nextSliderButton.addEventListener('click', goToNextContent);
              console.log(nextSliderButton);
            } else {
              iframes.push(frameBlock);
            }
          };

          

          elementObj.scale.x = 0.1;
          elementObj.scale.y = 0.1;
          elementObj.scale.z = 0.1;

          let elementObjCoord = new THREE.Cylindrical(101,(Math.PI) - (i*(2*Math.PI)/6));
          elementObj.position.setFromCylindrical(elementObjCoord);
          elementObj.lookAt(0,0,0);
          

          scene2.add( elementObj );
        }
        console.log(iframes);

        // var elementObj = makeElementObject( 'iframe', 1050, 800 );
        // elementObj.css3dObject.element.setAttribute('src', 'iframes/1.html');
        // elementObj.css3dObject.element.style.border = '1px solid transparent';
        // elementObj.css3dObject.element.style.borderRadius = '40px';
        // let frameBlock = elementObj.css3dObject.element;
        
        // frameBlock.onload = function(){
        //   let docBlock = frameBlock.contentDocument.querySelector('#slider');
        //   docBlock.style.display = 'block';
        //   let docBlock2 = frameBlock.contentDocument.querySelector('#info');
        //   docBlock2.style.display = 'none';
        //   // console.log (docBlock);
        // };

        // elementObj.position.x = 0;
        // elementObj.position.y = 0;
        // elementObj.position.z = -101;
        // elementObj.lookAt(0,0,0);
        // elementObj.scale.x = 0.1;
        // elementObj.scale.y = 0.1;
        // elementObj.scale.z = 0.1;

        // scene2.add( elementObj );


        // let elementObj2 = elementObj.css3dObject.clone();
        // console.log (elementObj2.element);
        // // // elementObj2.css3dObject.element.setAttribute('src', 'iframes/1.html');
        // // // elementObj2.css3dObject.element.style.border = '1px solid transparent';
        // // // elementObj2.css3dObject.element.style.borderRadius = '40px';
        // let frameBlock2 = elementObj2.element;
        
        // frameBlock2.onload = function(){
        //   let docBlock3 = frameBlock2.contentDocument.querySelector('#slider');
        //   docBlock3.style.display = 'none';
        //   let docBlock4 = frameBlock2.contentDocument.querySelector('#info');
        //   docBlock4.style.display = 'block';
        //   console.log (docBlock3);
        // };

        // elementObj2.position.x = 0;
        // elementObj2.position.y = 140;
        // elementObj2.position.z = -101;
        // elementObj2.lookAt(0,0,0);
        // elementObj2.scale.x = 0.1;
        // elementObj2.scale.y = 0.1;
        // elementObj2.scale.z = 0.1;

        // scene2.add( elementObj2 );

        // let testClone = elementObj.css3dObject.clone();
        // console.log(testClone);


        //add geometry
        for (let i=0; i<6; i++) {
          let objPlate2 = makePlate(1050/10 + 2,800/10 + 2,5);
          let box2 = new THREE.Box3().setFromObject( objPlate2 );
          box2.center(objPlate2.position);
          objPlate2.position.multiplyScalar(-1);
          let pivot2 = new THREE.Group();
          scene.add(pivot2);
          pivot2.add(objPlate2);
          let pivot2Coord = new THREE.Cylindrical(100, i*(2*Math.PI)/6);
          pivot2.position.setFromCylindrical(pivot2Coord);
          pivot2.lookAt(0,0,0);
        }

        // let objPlate = makePlate(1050/10,800/10,5);
        // let box = new THREE.Box3().setFromObject( objPlate );
        // box.center(objPlate.position);
        // objPlate.position.multiplyScalar(-1);
        // let pivot = new THREE.Group();
        // scene.add(pivot);
        // pivot.add(objPlate);
        // pivot.position.set(0,0,-90);
        // pivot.lookAt(0, 0, 0);


        // let objPlate2 = makePlate(1050/10,800/10,5);
        // let box2 = new THREE.Box3().setFromObject( objPlate2 );
        // box2.center(objPlate2.position);
        // objPlate2.position.multiplyScalar(-1);
        // let pivot2 = new THREE.Group();
        // scene.add(pivot2);
        // pivot2.add(objPlate2);
        // let pivot2Coord = new THREE.Cylindrical(90, QUARTER_CIRCLE);
        // pivot2.position.setFromCylindrical(pivot2Coord);
        // pivot2.lookAt(0,0,0);



        //add renderers
        raycaster = new THREE.Raycaster();

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setClearColor( 0x000000, 0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        // renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMappingExposure = 1;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
        document.querySelector('#webgl').appendChild( renderer.domElement );

        renderer2 = new CSS3DRenderer({ alpha: true, antialias: true });
				renderer2.setSize( window.innerWidth, window.innerHeight );
        renderer2.domElement.style.position = 'absolute';
        renderer2.domElement.style.top = 0;
        renderer2.domElement.style.pointerEvents = 'auto';
        // console.log(renderer2);
				document.querySelector('#webgl').appendChild( renderer2.domElement );

        //add light
        light = new THREE.AmbientLight( 0x999999, 1.5); 
        light2 = new THREE.AmbientLight( 0x999999, 1.5);// soft white light
        scene.add( light );
        scene2.add( light2 );


        //add controls
        controls = new OrbitControls(camera, renderer2.domElement );
        controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 1;
				controls.maxDistance = 1;
				controls.target.set(0, 0, 0);
        controls.update();
        controls.enabled = false;


        // controls2 = new FirstPersonControls( camera, renderer2.domElement );
				// controls2.lookSpeed = 0.01;
        // controls2.constrainVertical = true;
        // controls2.activeLook = true;


        
        // let tempCol = renderer2.domElement.firstElementChild;
        // console.log(Array.from(tempCol.children));
        // Array.from(tempCol.children).forEach(element => element.addEventListener('mouseenter', canselPointerEvent));
        // renderer2.domElement.addEventListener('mouseup', restorePointerEvent);
        // Array.from(tempCol.children).forEach(element => element.style.pointerEvents = 'none');
        

        // function canselPointerEvent (event) {
        //   console.log('canselPointerEvent');
        //   event.repeat = false;
        //   event.target.onmousedown = (function(ev) {ev.target.style.pointerEvents = 'none';})(event);
        //   // event.target.onmouseup = (function(ev) {ev.target.style.pointerEvents = 'auto';})(event);
        // }



        // function restorePointerEvent (event) {
        //   Array.from(tempCol.children).forEach(element => element.style.pointerEvents = 'auto');
        //   console.log('restorePointerEvent');
        // }
        

        window.addEventListener( 'resize', onWindowResize );
        document.addEventListener('keydown', restoreControl);
        document.addEventListener('keydown', info);
        document.addEventListener('keyup', deleteControl);
        document.addEventListener( 'mousemove', onMouseMove );
        document.addEventListener( 'wheel', onDocumentMouseWheel );

        document.addEventListener( 'mousemove', onPointerMove );
      }

      // Our Javascript will go here.


      function deleteControl (event) {
          if (event.code == 'Space') {

            camStatus = camera.rotation.clone();
            console.log(camera.rotation);
            controls.update();
            controls.enabled = false;
            camera.updateProjectionMatrix();
            orbitControlFlag = false;
            let tempCol = renderer2.domElement.firstElementChild;
            Array.from(tempCol.children).forEach(element => element.style.pointerEvents = 'auto');
          }
        }
      function restoreControl (event) {
        if (event.code == 'Space') {
          // console.log('up');
          controls.enabled = true;
          controlUpdateState = controls.update();
          orbitControlFlag = true;
          let tempCol = renderer2.domElement.firstElementChild;
          Array.from(tempCol.children).forEach(element => element.style.pointerEvents = 'none');
        }
      }

      function info (event) {
        if (event.code == 'Backspace') {
          console.log(camera);
        }
      }


      function onMouseMove( event ) {
        mouse.x = ( event.clientX - windowHalf.x );
        mouse.y = ( event.clientY - windowHalf.x );
      }

      function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
          renderer2.setSize( window.innerWidth, window.innerHeight );
          controls.handleResize();
      }

      function makeElementObject(type, width, height) {
          const obj = new THREE.Group;

          const element = document.createElement( type );
          element.style.width = width+'px';
          element.style.height = height+'px';
          element.style.opacity = 0.999;
          element.style.boxSizing = 'border-box';
          // color.getStyle()


          var css3dObject = new CSS3DObject(element);
          obj.css3dObject = css3dObject;

          obj.add(css3dObject);
          obj.castShadow = true;
          obj.receiveShadow = true;

          var material = new THREE.MeshPhongMaterial({
            opacity : 0.15,
            color : new THREE.Color( 0x111111 ),
            blending: THREE.NoBlending,
            side : THREE.DoubleSides,
          });

          var geometry = new THREE.BoxGeometry( width, height, 100 );
          var mesh = new THREE.Mesh( geometry, material );
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          obj.lightShadowMesh = mesh;
          // obj.add( mesh );

          return obj
      }

      function makePlate(w,h,r) {
        const roundedRectShape = new THREE.Shape();
        ( function roundedRect( ctx, x, y, width, height, radius ) {
          ctx.moveTo( x, y + radius );
          ctx.lineTo( x, y + height - radius );
          ctx.quadraticCurveTo( x, y + height, x + radius, y + height );
          ctx.lineTo( x + width - radius, y + height );
          ctx.quadraticCurveTo( x + width, y + height, x + width, y + height - radius );
          ctx.lineTo( x + width, y + radius );
          ctx.quadraticCurveTo( x + width, y, x + width - radius, y );
          ctx.lineTo( x + radius, y );
          ctx.quadraticCurveTo( x, y, x, y + radius );
        } )( roundedRectShape, 0, 0, w, h, r );

        const extrudeSettings = {
            steps: 6,
            amount: 0.5,
            bevelEnabled: true,
            bevelThickness: 0.1,
            bevelSize: 0.5,
            bevelSegments: 3
          };

        var material = new THREE.MeshPhysicalMaterial( {
          dithering: true,
          color: 0xFFFFFF,
          metalness: 0,
          roughness: 0.7,
          envMapIntensity: 1,
          depthWrite: false,
          transmission: 1, // use material.transmission for glass materials
          opacity: 1
        } );

        var geometry = new THREE.ExtrudeGeometry( roundedRectShape, extrudeSettings );
        var mesh = new THREE.Mesh( geometry, material );
        
        return mesh
      }

      function goToNextContent() {
        iframes.forEach(element => element.contentWindow.goToNextSlide());
      }

      // const envM = new RGBELoader()
			// 		.setDataType( THREE.UnsignedByteType )
			// 		.setPath("img/Skies_1/")
			// 		.load( 'machine_shop_02_8k.hdr', function ( texture ) {

			// 			const envMap = pmremGenerator.fromEquirectangular( texture ).texture;

			// 			// scene.background = envMap;
			// 			// scene.environment = envMap;

			// 			texture.dispose();
			// 			pmremGenerator.dispose();

      //       console.log(scene.environment);

			// 			render();
			// 		} );


      // const color = 0xFFFFFF;
      // const intensity = 1;
      // const light = new THREE.DirectionalLight(color, intensity);
      // light.position.set(0, 5, -5);
      // scene.add(light);

      // const light = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );
      // scene.add( light );

      // const pmremGenerator = new THREE.PMREMGenerator( renderer );
			// pmremGenerator.compileEquirectangularShader();


      function animate () {
        requestAnimationFrame( animate );
        // stats.update();


        if(!orbitControlFlag) {
          // camera.rotation.normalize();


          // target.x =camStatus.y + (1 - mouse.x ) * 0.0002;
          // target.y = camStatus.x + (1 - mouse.y ) * 0.0002;

          //   camera.rotation.x += 0.05*( target.y - camera.rotation.x );
          //   camera.rotation.y += 0.05*( target.x - camera.rotation.y);


          // camera.rotation.z = camStatus.z;
          


        } else {
          controls.update();
        }
        render();

      };

      function render() {

        renderer.render( scene, camera );
        renderer2.render( scene2, camera );
        // controls2.update(clock.getDelta() );

        raycaster.setFromCamera( pointer, camera );
        camera.lookAt(raycaster.ray.direction.x*0.1, raycaster.ray.direction.y*0.1, raycaster.ray.direction.z*0.1);

				const intersects = raycaster.intersectObjects( scene.children, true );

				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );
            console.log(INTERSECTED);
					}
				} else {
					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					INTERSECTED = null;
				}
      }

      function onDocumentMouseWheel( event ) {
        const fov = camera.fov + event.deltaY * 0.05;
        camera.fov = THREE.MathUtils.clamp( fov, 10, 75 );
        console.log(camera.fov);
        camera.updateProjectionMatrix();
      }

      function onPointerMove( event ) {

pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

}

    </script>

    <div id="css"></div>
    <div id="webgl"></div>

  
	</body>
</html>
