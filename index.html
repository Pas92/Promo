<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
    <title>My first three.js app</title>
    
		<style>
			body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
        }

        #css, #webgl {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
        }

        #css {
          background: transparent;
        }

        #css div div {
          pointer-events: auto !important;
        }

    </style>
    
  </head>
  
	<body>


		<script type="module">
      import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.129.0-chk6X8RSBl37CcZQlxof/mode=imports/optimized/three.js';
      import { RGBELoader } from 'https://cdn.skypack.dev/three@v0.129.0-chk6X8RSBl37CcZQlxof/examples/jsm/loaders/RGBELoader.js';
      import { GUI } from 'https://cdn.skypack.dev/three@v0.129.0-chk6X8RSBl37CcZQlxof/examples/jsm/libs/dat.gui.module.js';
			import { OrbitControls } from 'https://cdn.skypack.dev/three@v0.129.0-chk6X8RSBl37CcZQlxof/examples/jsm/controls/OrbitControls.js';
      import { CSS3DRenderer, CSS3DObject } from 'https://cdn.skypack.dev/three@v0.129.0-chk6X8RSBl37CcZQlxof/examples/jsm/renderers/CSS3DRenderer.js';
      // import { FirstPersonControls } from '/js/three/jsm/controls/FirstPersonControls.js';

      let camera, scene, scene2, renderer, renderer2, light, light2;
      let controls;
      const QUARTER_CIRCLE = Math.PI / 2;

      const clock = new THREE.Clock();

      const mouse = new THREE.Vector2();
      const target = new THREE.Vector2();
      const windowHalf = new THREE.Vector2( window.innerWidth / 2, window.innerHeight / 2 );

      

      init();
      render();
      animate(performance.now());

      function init(){
        //add camera
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 20;
        console.log(camera);

        //add scene
        scene = new THREE.Scene();
        scene2 = new THREE.Scene();
        console.log(scene);
        scene.background = new THREE.CubeTextureLoader()
          .setPath("img/Skies_1/background/")
          .load( [
            'px.png',
            'nx.png',
            'py.png',
            'ny.png',
            'pz.png',
            'nz.png'
          ] );
        
        //add domElement
        // let page1 = document.createElement('div');
        // page1.style.width = '1000px';
        // page1.style.height ='1000px';
        // page1.style.backgroundColor = '0xbbbbbb';
        // page1.style.opacity = '0.999';
        // // page1.setAttribute('src', '/iframes/1.html');

        // let product1 = new CSS3DObject(page1);
        // product1.position.x = 0;
        // product1.position.y = 0;
        // product1.position.z = 8;
        // scene.add(product1);
        // console.log(product1);

        var elementObj = makeElementObject( 'iframe', 1050, 800 );
        elementObj.css3dObject.element.setAttribute('src', 'iframes/1.html');
        elementObj.css3dObject.element.style.border = 'none';

        elementObj.position.x = 0;
        elementObj.position.y = 0;
        elementObj.position.z = -90;
        elementObj.scale.x = 0.1;
        elementObj.scale.y = 0.1;
        elementObj.scale.z = 0.1;

        scene2.add( elementObj );

        //add geometry
        let objPlate = makePlate(1050/10,800/10,5);
        objPlate.position.x = -(1050/10)/2;
        objPlate.position.y = -(800/10)/2;
        objPlate.position.z = -90;
        scene.add(objPlate);

        //add renderers
        

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setClearColor( 0x000000, 0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        // renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMappingExposure = 1;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
        document.querySelector('#webgl').appendChild( renderer.domElement );

        renderer2 = new CSS3DRenderer({ alpha: true, antialias: true });
				renderer2.setSize( window.innerWidth, window.innerHeight );
        renderer2.domElement.style.position = 'absolute';
        renderer2.domElement.style.top = 0;
        renderer2.domElement.style.pointerEvents = 'auto';
        console.log(renderer2);
				document.querySelector('#webgl').appendChild( renderer2.domElement );

        //add light
        light = new THREE.AmbientLight( 0x999999, 1.5); 
        light2 = new THREE.AmbientLight( 0x999999, 1.5);// soft white light
        scene.add( light );
        scene2.add( light2 );


        //add controls
        controls = new OrbitControls(camera, renderer2.domElement );
        // controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 1;
				controls.maxDistance = 1;
				controls.target.set( 0, 0, 0);
        controls.update();
        controls.enabled = false;

        // controls2 = new FirstPersonControls( camera, renderer2.domElement );
				// controls2.lookSpeed = 0.01;
        // controls2.constrainVertical = true;
        // controls2.activeLook = true;


        
        // let tempCol = renderer2.domElement.firstElementChild;
        // console.log(Array.from(tempCol.children));
        // Array.from(tempCol.children).forEach(element => element.addEventListener('mouseenter', canselPointerEvent));
        // renderer2.domElement.addEventListener('mouseup', restorePointerEvent);
        // Array.from(tempCol.children).forEach(element => element.style.pointerEvents = 'none');
        

        // function canselPointerEvent (event) {
        //   console.log('canselPointerEvent');
        //   event.repeat = false;
        //   event.target.onmousedown = (function(ev) {ev.target.style.pointerEvents = 'none';})(event);
        //   // event.target.onmouseup = (function(ev) {ev.target.style.pointerEvents = 'auto';})(event);
        // }



        // function restorePointerEvent (event) {
        //   Array.from(tempCol.children).forEach(element => element.style.pointerEvents = 'auto');
        //   console.log('restorePointerEvent');
        // }
        function deleteControl (event) {
          if (event.code == 'Space') {
            console.log('down');
            controls.enabled = false;
            let tempCol = renderer2.domElement.firstElementChild;
            Array.from(tempCol.children).forEach(element => element.style.pointerEvents = 'auto');
          }
        }
      function restoreControl (event) {
        if (event.code == 'Space') {
          console.log('up');
          controls.enabled = true;
          let tempCol = renderer2.domElement.firstElementChild;
          Array.from(tempCol.children).forEach(element => element.style.pointerEvents = 'none');
        }
      }

        window.addEventListener( 'resize', onWindowResize );
        document.addEventListener('keydown', restoreControl);
        document.addEventListener('keyup', deleteControl);
        document.addEventListener( 'mousemove', onMouseMove );
      }

      // Our Javascript will go here.


      function onMouseMove( event ) {
        mouse.x = ( event.clientX - windowHalf.x );
        mouse.y = ( event.clientY - windowHalf.x );
      }

      function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
          renderer2.setSize( window.innerWidth, window.innerHeight );
          controls.handleResize();
      }

      function makeElementObject(type, width, height) {
          const obj = new THREE.Group;

          const element = document.createElement( type );
          element.style.width = width+'px';
          element.style.height = height+'px';
          element.style.opacity = 0.999;
          element.style.boxSizing = 'border-box';
          // color.getStyle()


          var css3dObject = new CSS3DObject(element);
          obj.css3dObject = css3dObject;

          obj.add(css3dObject);
          obj.castShadow = true;
          obj.receiveShadow = true;

          var material = new THREE.MeshPhongMaterial({
            opacity : 0.15,
            color : new THREE.Color( 0x111111 ),
            blending: THREE.NoBlending,
            side : THREE.DoubleSides,
          });

          var geometry = new THREE.BoxGeometry( width, height, 100 );
          var mesh = new THREE.Mesh( geometry, material );
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          obj.lightShadowMesh = mesh;
          // obj.add( mesh );

          return obj
      }

      function makePlate(w,h,r) {
        const roundedRectShape = new THREE.Shape();
        ( function roundedRect( ctx, x, y, width, height, radius ) {
          ctx.moveTo( x, y + radius );
          ctx.lineTo( x, y + height - radius );
          ctx.quadraticCurveTo( x, y + height, x + radius, y + height );
          ctx.lineTo( x + width - radius, y + height );
          ctx.quadraticCurveTo( x + width, y + height, x + width, y + height - radius );
          ctx.lineTo( x + width, y + radius );
          ctx.quadraticCurveTo( x + width, y, x + width - radius, y );
          ctx.lineTo( x + radius, y );
          ctx.quadraticCurveTo( x, y, x, y + radius );
        } )( roundedRectShape, 0, 0, w, h, r );

        const extrudeSettings = {
            steps: 6,
            amount: 0.5,
            bevelEnabled: true,
            bevelThickness: 0.1,
            bevelSize: 0.5,
            bevelSegments: 3
          };

        var material = new THREE.MeshPhysicalMaterial( {
          dithering: true,
          color: 0xFFFFFF,
          metalness: 0,
          roughness: 0.7,
          envMapIntensity: 1,
          depthWrite: false,
          transmission: 1, // use material.transmission for glass materials
          opacity: 1
        } );

        var geometry = new THREE.ExtrudeGeometry( roundedRectShape, extrudeSettings );
        var mesh = new THREE.Mesh( geometry, material );
        
        return mesh
      }

      // const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight)

      // const envM = new RGBELoader()
			// 		.setDataType( THREE.UnsignedByteType )
			// 		.setPath("img/Skies_1/")
			// 		.load( 'machine_shop_02_8k.hdr', function ( texture ) {

			// 			const envMap = pmremGenerator.fromEquirectangular( texture ).texture;

			// 			// scene.background = envMap;
			// 			// scene.environment = envMap;

			// 			texture.dispose();
			// 			pmremGenerator.dispose();

      //       console.log(scene.environment);

			// 			render();
			// 		} );


      // const color = 0xFFFFFF;
      // const intensity = 1;
      // const light = new THREE.DirectionalLight(color, intensity);
      // light.position.set(0, 5, -5);
      // scene.add(light);

      

      // const light = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );
      // scene.add( light );

      

      // const pmremGenerator = new THREE.PMREMGenerator( renderer );
			// pmremGenerator.compileEquirectangularShader();


      function animate () {
        requestAnimationFrame( animate );
        // console.log(camera.rotation.x);
        // mesh.rotation.x += 0.01;
        // mesh.rotation.y += 0.01;

        target.x = ( 1 - mouse.x ) * 0.0002;
        target.y = ( 1 - mouse.y ) * 0.0002;
        camera.rotation.x += 0.05 * ( target.y - camera.rotation.x );
        camera.rotation.y += 0.05 * ( target.x - camera.rotation.y );
        render();
      };

      function render() {
        // renderer.setRenderTarget(renderTarget);

        renderer.render( scene, camera );
        renderer2.render( scene2, camera );
        // renderer.setRenderTarget(null);
        // controls.update();
        // controls2.update(clock.getDelta() );
      }

      function onDocumentMouseWheel( event ) {
        const fov = camera.fov + event.deltaY * 0.05;
        camera.fov = THREE.MathUtils.clamp( fov, 10, 75 );
        console.log(camera.fov);
        camera.updateProjectionMatrix();
      }

      document.addEventListener( 'wheel', onDocumentMouseWheel );

    </script>

    <div id="css"></div>
    <div id="webgl"></div>

  
	</body>
</html>
